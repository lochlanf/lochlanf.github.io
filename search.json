[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GNA5012 - Applied Bioinformatics",
    "section": "",
    "text": "Preface\nWelcome to GNA5012 - Applied Bioinformatics\nWelcome to the Course in Applied Bioinformatics! In this course, we will investigate the fascinating field of bioinformatics and its diverse applications in biological research. Bioinformatics combines the strengths of computer science, statistics, and biology in order to analyse and interpret large-scale biological data, ultimately leading to new discoveries and understandings.\nIn the past decade, advances in high-throughput technologies have generated a vast quantity of biological data, including genomic sequences, gene expression profiles, and protein structures. Bioinformatics plays a crucial role in making meaning of this wealth of information by providing the necessary tools and methodologies for data analysis, interpretation, and visualisation.\nThe objective of this course is to provide you with the knowledge and skills necessary to navigate the bioinformatics landscape and apply computational techniques to solve real-world biological problems. Whether you are a biologist interested in employing computational methods or a computer scientist eager to explore the fascinating world of biology, this course will provide a foundation for bridging the gap between these disciplines.\n\n\nCourse Learning Objectives\n\nEvaluate current techniques to generate genomic data and apply standard workflows to analyse them\nInvestigate gene set enrichment, network analysis and data visualisation protocols\nEvaluate quality and diagnose issues with raw sequencing data and assembled genomes\nPerform basic computer programming with case studies involving DNA pattern finding\nIdentify both small and large-scale genomic variants\nDemonstrate team work, scientific communication and peer to peer learning and feedback.\n\n\n\nLearning modes\nThis course is taught using a flipped class-room model. Each week you are expected to dedicate 2-3 hours perusing the online modules and engaging with readings. These course materials are designed to situate you for the practical elements of the course. We have two workshops, each running for 2 hours. In these sessions you will apply the concepts you have learned to real biological data sets. Attendance at these workshops is essential and successful completion of this course will be very difficult if you don’t take advantage of the applied sessions.\n\n\nNavigating the course manual\nThis book will serve as your course manual. On the left hand side of the screen you will notice that the book is broken into several chapters. Each chapter represents a weeks worth of practical activities. These are to be completed in class. At the conclusion of the book you will see several extension chapters. Complete these at your leisure to improve your bioinformatic ability. On the right is a table of contents for each chapter. Clicking these links will help you navigate between different activities. There is also a search bar to search the entire book."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "W1.html",
    "href": "W1.html",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "",
    "text": "2 Connecting to your Virtual Machine\nThere are several important steps to connect to your virtual machine.\nMac OSX/Linux based computers\nssh username@hostname\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\nType ‘Yes’\nWindows based computers\nNavigating on the command line is an important skill and mastery of navigation will substantially reduce your time troubleshooting basic path related errors. Before we introduce the basic commands used for navigation it is important to introduce the concept of relative and absolute paths. Both can be used to specify the location of a directory or file but there is an important distinction between them.\nAbsolute Path: The absolute path of a file or directory begins at the root directory and specifies the full location of a file in the file system. This is the exact path from the root / to the file, and does not rely on the current working directory. Absolute pathways always begin with a forward slash /. Here is an example of an absolute path:\nRelative path: The relative path of a file begins at the current working directory and tracks the path from this directory to a given file. Relative paths do not begin with /. Image we are currently the home directory. The relative path to shell-lesson-data would be:\nWhen things go wrong: By far the most common error we see when navigating or pointing to a file occurs when the path to that file is set incorrectly. If this is the case you will see the following error: No such file or directory. If you see this error you need to double check the accuracy of the path you have provided.\nThere are three key commands that we use for navigation."
  },
  {
    "objectID": "W1.html#exercise-1",
    "href": "W1.html#exercise-1",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "3.1 Exercise 1:",
    "text": "3.1 Exercise 1:\nUse the pwd command go print out your current working directory."
  },
  {
    "objectID": "W1.html#connecting-to-your-virtual-machine",
    "href": "W1.html#connecting-to-your-virtual-machine",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "1.1 Connecting to your Virtual Machine",
    "text": "1.1 Connecting to your Virtual Machine\nThere are several important steps to connect to your virtual machine.\nMac OSX/Linux based computers\n\nEnsure that you are connected to the Monash VPN. Instructions for connecting to the Monash VPN can be found here.\nGo to the search bar and type in “terminal”. This will open your machines terminal.\nTo connect to your virtual machine you need to execute the following command, replacing username with your trainee username and hostname with the corresponding hostname in the google sheet:\n\nssh username@hostname\n\nYou will be prompted to enter your password.\nYou may be prompted with the following message:\n\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\nType ‘Yes’\n\nYou are now successfully connected to the VPN. You should see something similar to this:\n\n\nWindows based computers\n\nEnsure that you are connected to the Monash VPN. Instructions for connecting to the Monash VPN can be found here.\nDownload and install PuTTY. PuTTY is an open-source SSH client for Windows and will allow you to connect to your virtual machine.\nWhen you open PuTTY you will be presented with the following:\n\nIn the “hostname” field, enter the hostname corresponding to your virtual machine as per the google sheet. Click the “open” button.\nYou will be prompted to enter a username. Enter the username that corresponds to your virtual machine. Hit enter.\nYou will be prompted to enter a password. Enter the password that corresponds to your virtual machine. Note: Your password will not be visible as you type it. This is normal. Hit Enter.\nYou should now be connected to your virtual machine."
  },
  {
    "objectID": "W1.html#navigating-on-the-command-line",
    "href": "W1.html#navigating-on-the-command-line",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "1.2 Navigating on the command line",
    "text": "1.2 Navigating on the command line\nNavigating on the command line is an important skill and mastery of navigation will substantially reduce your time troubleshooting basic path related errors. Before we introduce the basic commands used for navigation it is important to introduce the concept of relative and absolute paths. Both can be used to specify the location of a directory or file but there is an important distinction between them.\nAbsolute Path: The absolute path of a file or directory begins at the root directory and specifies the full location of a file in the file system. This is the exact path from the root / to the file, and does not rely on the current working directory. Absolute pathways always begin with a forward slash /. Here is an example of an absolute path:\n\n/home/trainee32/shell-lesson-data\n\nRelative path: The relative path of a file begins at the current working directory and tracks the path from this directory to a given file. Relative paths do not begin with /. Image we are currently the home directory. The relative path to shell-lesson-data would be:\n\ntrainee32/shell-lesson-data\n\nWhen things go wrong: By far the most common error we see when navigating or pointing to a file occurs when the path to that file is set incorrectly. If this is the case you will see the following error: No such file or directory. If you see this error you need to double check the accuracy of the path you have provided.\nThere are three key commands that we use for navigation.\n\npwd - This command will tell you where you are currently working.\n\n\nExercise 1:\nUse the pwd command to print out your current working directory to the terminal. What do you notice about the path that is returned? Is it absolute or relative? How can you tell?\n\n\ncd - This command will change your current working directory (hence the name cd). The syntax for this command is cd desired_path. desired_path can be absolute or relative. You will use this command to move around within your virtual environment.\n\nLet’s imagine we are in our home directory, which in this case is /users/student1\n\n\n\n\n\n\n\n\n\nCurrent working directory\nCommand\nNew working directory\nExplanation\n\n\n\n\n/users/student1\ncd .\n/users/student1\nThe . operator stands for your present directory. cd will not alter the working directory in response to this\n\n\n/users/student1\ncd ..\n/users\nThe .. operator will move you one level up the tree to the parent directory.\n\n\n/users/student1\ncd week_1\n/users/student/week_1\nThis command will move you to the week_1 directory which resides in your working directory.\n\n\n/users/student/week_1\ncd ~\n/users/student1\nThe ~ symbol represents your home directory and we are thus returned there\n\n\n/users/student1\ncd /\n/\nThe / symbol represents the root of the filesystem. This command will take you to the very top of the tree!\n\n\n\n\nExercise 2:\nUse the cd command to navigate to the week_1 directory. You can use either relative or absolute paths to achieve this. Note that if you use the absolute path, you should take note of your current working directory as noted in exercise 1.\n\n\nls - The last command in this series is the ls command. This command with list the contents of your current working directory. This is akin to viewing the contents of a directory using a graphical user interface.\n\n\nExercise 3:\nUse the ls command to list the contents of the week_1 directory. There are several options associated with this command. You can view these (and options associated with any other command) using the man command. Try out a few, especially the -a option. What do you notice?"
  },
  {
    "objectID": "W1.html#creating-files-and-directories",
    "href": "W1.html#creating-files-and-directories",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "1.3 Creating files and directories",
    "text": "1.3 Creating files and directories\nWe can create files and directories using the touch and mkdir commands. Touch will create an empty file and mkdir will create a new directory. Lets give it a try:\n\nExercise 4:\nWithin the week_1 directory, create a directory called “src”. Within this directory, create an empty file called script_1.sh"
  },
  {
    "objectID": "W1.html#copying-moving-and-deleting-files",
    "href": "W1.html#copying-moving-and-deleting-files",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "1.4 Copying, moving and deleting files",
    "text": "1.4 Copying, moving and deleting files\nThere are occasions when we want to copy, move or even delete files from the shell. This can be achieved using the cp, mv and rm functions, respectively.\n\nThe basic syntax for cp and mv is as follows: cp source_file target_file\n\n\nExercise 5:\nWithin the week_1 directory, create a couple of files using the touch command. Explore the cp and mv commands by moving these files around and creating new copies. When you are done clean up the files you have created with rm."
  },
  {
    "objectID": "W1.html#wild-cards",
    "href": "W1.html#wild-cards",
    "title": "1  Week 1 - Introduction to the shell",
    "section": "1.5 Wild cards",
    "text": "1.5 Wild cards\nSometimes when we are performing tasks in bash we would like to identify patterns in text strings. For instance, I might have a large set of fastq files from a paired-end sequencing run. Read pairs are usually denoted by R1 and R2. I can use wild cards to identify all the R1 fastq files in a directory in a directory by using the following command\nls *R1.fastq\nThere are several wildcards in Bash:\n\nThese can be integrated into any commands where finding strings and patterns are useful. Several wildcards can be combined within a single string, making them a very powerful tool.\n\n\n\n\n\n\n\n\nWildcard\nDescription\nExample\nOutput\n\n\n\n\n*\nMatches any number of characters.\nls *.pdf\nAll files with the .pdf file extension\n\n\n?\nMatches any single character.\nls sample_1.?am\nAll files with an extension that starts with any character and is followed by am. Examples might include sample_1.bam or sample_1.sam\n\n\n[]\nMatches any single character within a range or set\nls sample_[123].sam\nReturns sample_1.sam, sample_2.sam, and sample_3.sam if they exist\n\n\n{}\nExpands a comma-separated list of strings or characters\nls sample_1.{sam,bam}\nReturns sample_1.sam and sample_1.bam\n\n\n\n\nExercise 6:\nLet’s try a few examples. In the data/sequences you will find a set of DNA sequences in FASTA format. Each file contains a different number of sequences. FASTA files contain a descriptor line, which is indicated by the > symbol, and a line containing the sequence of nucleotides. We can use the wc tool to evaluate the number of lines in a file. Use the wc tool and wild-card expressions to determine the number of sequences in each file. (Hint - if you are unsure about wc, check out the manual using man wc"
  },
  {
    "objectID": "W1_1.html#connecting-to-your-virtual-machine",
    "href": "W1_1.html#connecting-to-your-virtual-machine",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "2.1 Connecting to your Virtual Machine",
    "text": "2.1 Connecting to your Virtual Machine\nThere are several important steps to connect to your virtual machine.\nMac OSX/Linux based computers\n\nEnsure that you are connected to the Monash VPN. Instructions for connecting to the Monash VPN can be found here.\nGo to the search bar and type in “terminal”. This will open your machines terminal.\nTo connect to your virtual machine you need to execute the following command, replacing username with your trainee username and hostname with the corresponding hostname in the google sheet:\n\nssh username@hostname\n\nYou will be prompted to enter your password.\nYou may be prompted with the following message:\n\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\nType ‘Yes’\n\nYou are now successfully connected to the VPN. You should see something similar to this:\n\n\nWindows based computers\n\nEnsure that you are connected to the Monash VPN. Instructions for connecting to the Monash VPN can be found here.\nDownload and install PuTTY. PuTTY is an open-source SSH client for Windows and will allow you to connect to your virtual machine.\nWhen you open PuTTY you will be presented with the following:\n\nIn the “hostname” field, enter the hostname corresponding to your virtual machine as per the google sheet. Click the “open” button.\nYou will be prompted to enter a username. Enter the username that corresponds to your virtual machine. Hit enter.\nYou will be prompted to enter a password. Enter the password that corresponds to your virtual machine. Note: Your password will not be visible as you type it. This is normal. Hit Enter.\nYou should now be connected to your virtual machine."
  },
  {
    "objectID": "W1_1.html#navigating-on-the-command-line",
    "href": "W1_1.html#navigating-on-the-command-line",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "2.2 Navigating on the command line",
    "text": "2.2 Navigating on the command line\nNavigating on the command line is an important skill and mastery of navigation will substantially reduce your time troubleshooting basic path related errors. Before we introduce the basic commands used for navigation it is important to introduce the concept of relative and absolute paths. Both can be used to specify the location of a directory or file but there is an important distinction between them.\nAbsolute Path: The absolute path of a file or directory begins at the root directory and specifies the full location of a file in the file system. This is the exact path from the root / to the file, and does not rely on the current working directory. Absolute pathways always begin with a forward slash /. Here is an example of an absolute path:\n\n/home/trainee32/shell-lesson-data\n\nRelative path: The relative path of a file begins at the current working directory and tracks the path from this directory to a given file. Relative paths do not begin with /. Image we are currently the home directory. The relative path to shell-lesson-data would be:\n\ntrainee32/shell-lesson-data\n\nWhen things go wrong: By far the most common error we see when navigating or pointing to a file occurs when the path to that file is set incorrectly. If this is the case you will see the following error: No such file or directory. If you see this error you need to double check the accuracy of the path you have provided.\nThere are three key commands that we use for navigation.\n\npwd - This command will tell you where you are currently working.\n\n\nExercise 1:\nUse the pwd command to print out your current working directory to the terminal. What do you notice about the path that is returned? Is it absolute or relative? How can you tell?\n\n\ncd - This command will change your current working directory (hence the name cd). The syntax for this command is cd desired_path. desired_path can be absolute or relative. You will use this command to move around within your virtual environment.\n\nLet’s imagine we are in our home directory, which in this case is /users/student1\n\n\n\n\n\n\n\n\n\nCurrent working directory\nCommand\nNew working directory\nExplanation\n\n\n\n\n/users/student1\ncd .\n/users/student1\nThe . operator stands for your present directory. cd will not alter the working directory in response to this\n\n\n/users/student1\ncd ..\n/users\nThe .. operator will move you one level up the tree to the parent directory.\n\n\n/users/student1\ncd week_1\n/users/student/week_1\nThis command will move you to the week_1 directory which resides in your working directory.\n\n\n/users/student/week_1\ncd ~\n/users/student1\nThe ~ symbol represents your home directory and we are thus returned there\n\n\n/users/student1\ncd /\n/\nThe / symbol represents the root of the filesystem. This command will take you to the very top of the tree!\n\n\n\n\nExercise 2:\nUse the cd command to navigate to the week_1 directory. You can use either relative or absolute paths to achieve this. Note that if you use the absolute path, you should take note of your current working directory as noted in exercise 1.\n\n\nls - The last command in this series is the ls command. This command with list the contents of your current working directory. This is akin to viewing the contents of a directory using a graphical user interface.\n\n\nExercise 3:\nUse the ls command to list the contents of the week_1 directory. There are several options associated with this command. You can view these (and options associated with any other command) using the man command. Try out a few, especially the -a option. What do you notice?"
  },
  {
    "objectID": "W1_1.html#creating-files-and-directories",
    "href": "W1_1.html#creating-files-and-directories",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "2.3 Creating files and directories",
    "text": "2.3 Creating files and directories\nWe can create files and directories using the touch and mkdir commands. Touch will create an empty file and mkdir will create a new directory. Lets give it a try:\n\nExercise 4:\nWithin the week_1 directory, create a directory called “src”. Within this directory, create an empty file called script_1.sh"
  },
  {
    "objectID": "W1_1.html#copying-moving-and-deleting-files",
    "href": "W1_1.html#copying-moving-and-deleting-files",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "2.4 Copying, moving and deleting files",
    "text": "2.4 Copying, moving and deleting files\nThere are occasions when we want to copy, move or even delete files from the shell. This can be achieved using the cp, mv and rm functions, respectively.\n\nThe basic syntax for cp and mv is as follows: cp source_file target_file\n\n\nExercise 5:\nWithin the week_1 directory, create a couple of files using the touch command. Explore the cp and mv commands by moving these files around and creating new copies. When you are done clean up the files you have created with rm."
  },
  {
    "objectID": "W1_1.html#wild-cards",
    "href": "W1_1.html#wild-cards",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "2.5 Wild cards",
    "text": "2.5 Wild cards\nSometimes when we are performing tasks in bash we would like to identify patterns in text strings. For instance, I might have a large set of fastq files from a paired-end sequencing run. Read pairs are usually denoted by R1 and R2. I can use wild cards to identify all the R1 fastq files in a directory in a directory by using the following command\nls *R1.fastq\nThere are several wildcards in Bash:\n\nThese can be integrated into any commands where finding strings and patterns are useful. Several wildcards can be combined within a single string, making them a very powerful tool.\n\n\n\n\n\n\n\n\nWildcard\nDescription\nExample\nOutput\n\n\n\n\n*\nMatches any number of characters.\nls *.pdf\nAll files with the .pdf file extension\n\n\n?\nMatches any single character.\nls sample_1.?am\nAll files with an extension that starts with any character and is followed by am. Examples might include sample_1.bam or sample_1.sam\n\n\n[]\nMatches any single character within a range or set\nls sample_[123].sam\nReturns sample_1.sam, sample_2.sam, and sample_3.sam if they exist\n\n\n{}\nExpands a comma-separated list of strings or characters\nls sample_1.{sam,bam}\nReturns sample_1.sam and sample_1.bam\n\n\n\n\nExercise 6:\nLet’s try a few examples. In the data/sequences you will find a set of DNA sequences in FASTA format. Each file contains a different number of sequences. FASTA files contain a descriptor line, which is indicated by the > symbol, and a line containing the sequence of nucleotides. We can use the wc tool to evaluate the number of lines in a file. Use the wc tool and wild-card expressions to determine the number of sequences in each file. (Hint - if you are unsure about wc, check out the manual using man wc"
  },
  {
    "objectID": "W1_2.html#connecting-to-your-virtual-machine",
    "href": "W1_2.html#connecting-to-your-virtual-machine",
    "title": "2  Week 1 Workshop B - Introduction to the shell",
    "section": "2.1 Connecting to your Virtual Machine",
    "text": "2.1 Connecting to your Virtual Machine\nThere are several important steps to connect to your virtual machine.\nMac OSX/Linux based computers\n\nEnsure that you are connected to the Monash VPN. Instructions for connecting to the Monash VPN can be found here.\nGo to the search bar and type in “terminal”. This will open your machines terminal.\nTo connect to your virtual machine you need to execute the following command, replacing username with your trainee username and hostname with the corresponding hostname in the google sheet:\n\nssh username@hostname\n\nYou will be prompted to enter your password.\nYou may be prompted with the following message:\n\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\nType ‘Yes’\n\nYou are now successfully connected to the VPN. You should see something similar to this:\n\n\nWindows based computers\n\nEnsure that you are connected to the Monash VPN. Instructions for connecting to the Monash VPN can be found here.\nDownload and install PuTTY. PuTTY is an open-source SSH client for Windows and will allow you to connect to your virtual machine.\nWhen you open PuTTY you will be presented with the following:\n\nIn the “hostname” field, enter the hostname corresponding to your virtual machine as per the google sheet. Click the “open” button.\nYou will be prompted to enter a username. Enter the username that corresponds to your virtual machine. Hit enter.\nYou will be prompted to enter a password. Enter the password that corresponds to your virtual machine. Note: Your password will not be visible as you type it. This is normal. Hit Enter.\nYou should now be connected to your virtual machine."
  },
  {
    "objectID": "W1_2.html#navigating-on-the-command-line",
    "href": "W1_2.html#navigating-on-the-command-line",
    "title": "2  Week 1 Workshop B - Introduction to the shell",
    "section": "2.2 Navigating on the command line",
    "text": "2.2 Navigating on the command line\nNavigating on the command line is an important skill and mastery of navigation will substantially reduce your time troubleshooting basic path related errors. Before we introduce the basic commands used for navigation it is important to introduce the concept of relative and absolute paths. Both can be used to specify the location of a directory or file but there is an important distinction between them.\nAbsolute Path: The absolute path of a file or directory begins at the root directory and specifies the full location of a file in the file system. This is the exact path from the root / to the file, and does not rely on the current working directory. Absolute pathways always begin with a forward slash /. Here is an example of an absolute path:\n\n/home/trainee32/shell-lesson-data\n\nRelative path: The relative path of a file begins at the current working directory and tracks the path from this directory to a given file. Relative paths do not begin with /. Image we are currently the home directory. The relative path to shell-lesson-data would be:\n\ntrainee32/shell-lesson-data\n\nWhen things go wrong: By far the most common error we see when navigating or pointing to a file occurs when the path to that file is set incorrectly. If this is the case you will see the following error: No such file or directory. If you see this error you need to double check the accuracy of the path you have provided.\nThere are three key commands that we use for navigation.\n\npwd - This command will tell you where you are currently working.\n\n\nExercise 1:\nUse the pwd command to print out your current working directory to the terminal. What do you notice about the path that is returned? Is it absolute or relative? How can you tell?\n\n\ncd - This command will change your current working directory (hence the name cd). The syntax for this command is cd desired_path. desired_path can be absolute or relative. You will use this command to move around within your virtual environment.\n\nLet’s imagine we are in our home directory, which in this case is /users/student1\n\n\n\n\n\n\n\n\n\nCurrent working directory\nCommand\nNew working directory\nExplanation\n\n\n\n\n/users/student1\ncd .\n/users/student1\nThe . operator stands for your present directory. cd will not alter the working directory in response to this\n\n\n/users/student1\ncd ..\n/users\nThe .. operator will move you one level up the tree to the parent directory.\n\n\n/users/student1\ncd week_1\n/users/student/week_1\nThis command will move you to the week_1 directory which resides in your working directory.\n\n\n/users/student/week_1\ncd ~\n/users/student1\nThe ~ symbol represents your home directory and we are thus returned there\n\n\n/users/student1\ncd /\n/\nThe / symbol represents the root of the filesystem. This command will take you to the very top of the tree!\n\n\n\n\nExercise 2:\nUse the cd command to navigate to the week_1 directory. You can use either relative or absolute paths to achieve this. Note that if you use the absolute path, you should take note of your current working directory as noted in exercise 1.\n\n\nls - The last command in this series is the ls command. This command with list the contents of your current working directory. This is akin to viewing the contents of a directory using a graphical user interface.\n\n\nExercise 3:\nUse the ls command to list the contents of the week_1 directory. There are several options associated with this command. You can view these (and options associated with any other command) using the man command. Try out a few, especially the -a option. What do you notice?"
  },
  {
    "objectID": "W1_2.html#creating-files-and-directories",
    "href": "W1_2.html#creating-files-and-directories",
    "title": "2  Week 1 Workshop B - Introduction to the shell",
    "section": "2.3 Creating files and directories",
    "text": "2.3 Creating files and directories\nWe can create files and directories using the touch and mkdir commands. Touch will create an empty file and mkdir will create a new directory. Lets give it a try:\n\nExercise 4:\nWithin the week_1 directory, create a directory called “src”. Within this directory, create an empty file called script_1.sh"
  },
  {
    "objectID": "W1_2.html#copying-moving-and-deleting-files",
    "href": "W1_2.html#copying-moving-and-deleting-files",
    "title": "2  Week 1 Workshop B - Introduction to the shell",
    "section": "2.4 Copying, moving and deleting files",
    "text": "2.4 Copying, moving and deleting files\nThere are occasions when we want to copy, move or even delete files from the shell. This can be achieved using the cp, mv and rm functions, respectively.\n\nThe basic syntax for cp and mv is as follows: cp source_file target_file\n\n\nExercise 5:\nWithin the week_1 directory, create a couple of files using the touch command. Explore the cp and mv commands by moving these files around and creating new copies. When you are done clean up the files you have created with rm."
  },
  {
    "objectID": "W1_2.html#wild-cards",
    "href": "W1_2.html#wild-cards",
    "title": "2  Week 1 Workshop B - Introduction to the shell",
    "section": "2.5 Wild cards",
    "text": "2.5 Wild cards\nSometimes when we are performing tasks in bash we would like to identify patterns in text strings. For instance, I might have a large set of fastq files from a paired-end sequencing run. Read pairs are usually denoted by R1 and R2. I can use wild cards to identify all the R1 fastq files in a directory in a directory by using the following command\nls *R1.fastq\nThere are several wildcards in Bash:\n\nThese can be integrated into any commands where finding strings and patterns are useful. Several wildcards can be combined within a single string, making them a very powerful tool.\n\n\n\n\n\n\n\n\nWildcard\nDescription\nExample\nOutput\n\n\n\n\n*\nMatches any number of characters.\nls *.pdf\nAll files with the .pdf file extension\n\n\n?\nMatches any single character.\nls sample_1.?am\nAll files with an extension that starts with any character and is followed by am. Examples might include sample_1.bam or sample_1.sam\n\n\n[]\nMatches any single character within a range or set\nls sample_[123].sam\nReturns sample_1.sam, sample_2.sam, and sample_3.sam if they exist\n\n\n{}\nExpands a comma-separated list of strings or characters\nls sample_1.{sam,bam}\nReturns sample_1.sam and sample_1.bam\n\n\n\n\nExercise 6:\nLet’s try a few examples. In the data/sequences you will find a set of DNA sequences in FASTA format. Each file contains a different number of sequences. FASTA files contain a descriptor line, which is indicated by the > symbol, and a line containing the sequence of nucleotides. We can use the wc tool to evaluate the number of lines in a file. Use the wc tool and wild-card expressions to determine the number of sequences in each file. (Hint - if you are unsure about wc, check out the manual using man wc"
  },
  {
    "objectID": "W1_1.html#working-with-file-content",
    "href": "W1_1.html#working-with-file-content",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "2.6 Working with file content",
    "text": "2.6 Working with file content\nThere are several ways we can work with the contents of files in Bash. To view files we can leverage a suite of in-built tools, including cat, less, head and tail\n\n\n\n\n\n\n\n\nCommand\nDescription\nUse case\n\n\n\n\ncat\nThis command will concatenate files and return the contents to standard output (the terminal).\n\nTo view the entire contents of a file\nTo combine several files\n\n\n\nless\nThis command will display the contents of a file in your terminal window. You can move through the file using the up and down arrows. You exit the program by typing q.\n\nTo view and navigate the contents of a file\n\n\n\nhead\nThis command will print out the first n lines of a file. By default this is 10. Different options can be set to modify this.\n\nView the header of a file\n\n\n\ntail\nThis command will print out the last n lines of a file. By default this is 10. Different options can be set to modify this.\n\nView the end of a file"
  },
  {
    "objectID": "W1_1.html",
    "href": "W1_1.html",
    "title": "1  Week 1 Workshop A - Introduction to the shell",
    "section": "",
    "text": "2 Working on the command line\nBioinformatic analysis is conducted using a command-line interface (CLI). This is a text-based interface that allows users to interact directly with the computers operating system by executing commands. This is in contrast with the graphical user interface (GUI) that you might be familiar with, where instructions are sent to the computer via a point-aim-click mechanism. Below is an example of how one might view the contents of a directory using a CLI (Left) and a GUI (Right). The most common shells are Bash and Zsh. These shells typically operate in Unix based operating systems. We will be using Ubuntu-based virtual machines in this course.\nShell scripting can be very useful in bioinformatics including"
  }
]